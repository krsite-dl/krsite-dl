name: Create Reusable Tag

on:
  workflow_call:
    inputs:
      release_type:
        description: "The type of release to create (release or prerelease)"
        required: true
        type: string
    outputs:
      new_tag:
        description: "The newly created SemVer tag"
        value: ${{ jobs.tag.outputs.new_tag }}

jobs:
  tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create SemVer Tag based on release type
        id: create_tag
        run: |
          #!/bin/bash
          # Exit immediately if a command exits with a non-zero status.
          set -e
          # Be verbose and print commands for better debugging.
          set -x

          # 1. Fetch all tags.
          git fetch --tags
          
          # --- NEW ROBUST TAG DETECTION ---
          # Get the absolute latest tag (might be an RC)
          latest_tag=$(git tag --sort=-v:refname | head -n 1)
          
          # Get the latest STABLE tag (no -rc)
          latest_stable=$(git tag --sort=-v:refname | grep -v "\-rc" | head -n 1 || echo "")

          echo "Detected latest tag: $latest_tag"
          echo "Detected latest stable: $latest_stable"

          # Determine which one to use as the base for version math.
          # If 3.0.0 exists, we should usually base off 3.0.0 even if 3.0.0-rc.0 exists.
          use_tag="$latest_tag"
          if [ -n "$latest_stable" ]; then
              # Strip 'v' for comparison
              v_stable="${latest_stable#v}"
              v_latest="${latest_tag#v}"
              v_latest_base="${v_latest%-rc.*}"

              # If the latest tag is just an RC for the current stable, use the stable.
              # Example: latest=3.0.0-rc.0, stable=3.0.0 -> Use 3.0.0
              if [ "$v_latest_base" == "$v_stable" ]; then
                  use_tag="$latest_stable"
              fi
          fi
          
          # 2. Determine the base version and whether the used tag is a prerelease.
          base_version=""
          is_prerelease=false
          has_v_prefix=false

          echo "Using tag $use_tag as the base for calculation."
          
          # Check for 'v' prefix
          if [[ "$use_tag" =~ ^v ]]; then
            has_v_prefix=true
            clean_tag="${use_tag#v}"
          else
            clean_tag="$use_tag"
          fi

          if echo "$clean_tag" | grep -q -- "-rc\."; then
            is_prerelease=true
            base_version=$(echo "$clean_tag" | sed -E 's/-rc\.[0-9]+$//')
          else
            is_prerelease=false
            base_version="$clean_tag"
          fi
          
          # Final safety for empty base
          base_version="${base_version:-0.0.0}"
          echo "Base version for calculation is $base_version. Is prerelease: $is_prerelease."

          # 3. Get all commits since the 'use_tag'
          commits=""
          if [ -z "$use_tag" ]; then
            commits=$(git log --oneline)
          else
            commits=$(git log "${use_tag}"..HEAD --oneline)
          fi

          # 4. Determine bump type
          bump_type="none"
          if echo "$commits" | grep -q -E "(BREAKING CHANGE)|(!:)"; then
            bump_type="major"
          elif echo "$commits" | grep -q -E "[a-f0-9]+ feat(\(.*\))?:"; then
            bump_type="minor"
          elif echo "$commits" | grep -q -E "[a-f0-9]+ (fix|build|chore|ci|docs|perf|refactor|revert|style|test)(\(.*\))?:"; then
            bump_type="patch"
          fi
          echo "Determined bump type: $bump_type"

          # 5. Calculate next version
          IFS='.' read -r major minor patch <<< "$base_version"
          major=${major:-0}; minor=${minor:-0}; patch=${patch:-0}

          if [ "$bump_type" == "major" ]; then
            major=$((major + 1)); minor=0; patch=0;
          elif [ "$bump_type" == "minor" ]; then
            minor=$((minor + 1)); patch=0;
          elif [ "$bump_type" == "patch" ]; then
            # Only increment patch if we are starting from a stable tag.
            # If we are on an RC, the patch is already "contained" in the target version.
            if [ "$is_prerelease" = false ]; then
              patch=$((patch + 1))
            fi
          fi
          next_version="${major}.${minor}.${patch}"

          # 6. Determine final tag
          RELEASE_TYPE="${RELEASE_TYPE:-release}"
          new_tag=""
          if [ "$RELEASE_TYPE" == "release" ]; then
            new_tag="$next_version"
          else
            # For prerelease, check if we need to increment existing RC
            if [ "$is_prerelease" = true ] && [ "$next_version" == "$base_version" ]; then
                rc_number=$(echo "$use_tag" | sed -E 's/.*-rc\.//')
                new_rc_number=$((rc_number + 1))
                new_tag="${base_version}-rc.${new_rc_number}"
            else
                new_tag="${next_version}-rc.0"
            fi
          fi

          # 0.0.0 Safety
          if [ "$new_tag" == "0.0.0" ] || [ "$new_tag" == "0.0.0-rc.0" ]; then
              new_tag=$([ "$RELEASE_TYPE" == "release" ] && echo "0.1.0" || echo "0.1.0-rc.0")
          fi

          # Re-add prefix
          [ "$has_v_prefix" = true ] && new_tag="v$new_tag"

          echo "Final selected tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Push new tag to repository
        if: steps.create_tag.outputs.new_tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag ${{ steps.create_tag.outputs.new_tag }}
          git push origin ${{ steps.create_tag.outputs.new_tag }}