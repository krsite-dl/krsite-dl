name: Create Reusable Tag

on:
  workflow_call:
    inputs:
      release_type:
        description: "The type of release to create (release or prerelease)"
        required: true
        type: string
    outputs:
      new_tag:
        description: "The newly created SemVer tag"
        value: ${{ jobs.tag.outputs.new_tag }}

jobs:
  tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create SemVer Tag based on release type
        id: create_tag
        run: |
          #!/bin/bash
          # Exit immediately if a command exits with a non-zero status.
          set -e
          # Be verbose and print commands for better debugging.
          set -x

          # 1. SETUP: Fetch all tags and determine the current state.
          # It's crucial to fetch all tags from the remote repository.
          echo "Fetching all tags from remote..."
          git fetch --tags

          latest_tag=$(git tag --sort=-v:refname | head -n 1)
          latest_stable_tag=$(git tag --list '[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n 1)
          
          is_latest_a_prerelease=false
          if echo "$latest_tag" | grep -q -- "-rc\."; then
            is_latest_a_prerelease=true
          fi
          echo "Latest tag found: $latest_tag (is prerelease: $is_latest_a_prerelease)"
          echo "Latest stable tag found: $latest_stable_tag"

          # 2. CALCULATIONS: Compute all possible next versions ahead of time.

          # --- Possibility A: Calculate the next version based on commits since the last STABLE tag.
          next_version_from_commits=""
          if [ -z "$latest_stable_tag" ]; then
            # Handle the case where no stable tags exist yet.
            next_version_from_commits="0.1.0"
          else
            commits=$(git log ${latest_stable_tag}..HEAD --oneline)
            major=$(echo $latest_stable_tag | cut -d. -f1)
            minor=$(echo $latest_stable_tag | cut -d. -f2)
            patch=$(echo $latest_stable_tag | cut -d. -f3)
            
            if echo "$commits" | grep -q -E "(BREAKING CHANGE)|(!)"; then
              major=$((major + 1)); minor=0; patch=0;
            elif echo "$commits" | grep -q "(feat)"; then
              minor=$((minor + 1)); patch=0;
            elif echo "$commits" | grep -q "(fix)"; then
              patch=$((patch + 1));
            # If there are commits, but they don't match a type, default to patch.
            elif [ -n "$commits" ]; then
              patch=$((patch + 1));
            fi
            next_version_from_commits="${major}.${minor}.${patch}"
          fi
          echo "Calculation A (next version from commits): $next_version_from_commits"

          # --- Possibility B: Promote the latest prerelease to a stable release.
          promoted_from_prerelease=""
          if $is_latest_a_prerelease; then
            promoted_from_prerelease=$(echo $latest_tag | sed -E 's/-rc\.[0-9]+$//')
          fi
          echo "Calculation B (promoted prerelease): $promoted_from_prerelease"

          # --- Possibility C: Increment the rc number of the latest prerelease.
          next_prerelease_from_latest=""
          if $is_latest_a_prerelease; then
            base_version=$(echo $latest_tag | sed -E 's/-rc\.[0-9]+$//')
            rc_number=$(echo $latest_tag | sed -E 's/.*-rc\.//')
            new_rc_number=$((rc_number + 1))
            next_prerelease_from_latest="${base_version}-rc.${new_rc_number}"
          fi
          echo "Calculation C (next prerelease from latest): $next_prerelease_from_latest"


          # 3. SELECTION: Choose the correct tag based on user input and the repository's state.
          new_tag=""
          if [ "${{ inputs.release_type }}" == "release" ]; then
            # --- User wants a STABLE release ---
            echo "ACTION: Selecting a stable release tag."
            if $is_latest_a_prerelease; then
              # Rule 3: If release then 1.0.1-rc.5 --> 1.0.1
              new_tag=$promoted_from_prerelease
            else
              # Rule 4: If release then 1.0.1 --> 1.0.2
              new_tag=$next_version_from_commits
            fi
          else
            # --- User wants a PRERELEASE ---
            echo "ACTION: Selecting a pre-release tag."
            if $is_latest_a_prerelease; then
              # Rule 1: If pre-release then 1.0.1-rc.0 --> 1.0.1-rc.1
              new_tag=$next_prerelease_from_latest
            else
              # Rule 2: If pre-release then 1.0.1 --> 1.0.2-rc.0
              new_tag="${next_version_from_commits}-rc.0"
            fi
          fi

          echo "Final selected tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Push new tag to repository
        if: steps.create_tag.outputs.new_tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag ${{ steps.create_tag.outputs.new_tag }}
          git push origin ${{ steps.create_tag.outputs.new_tag }}