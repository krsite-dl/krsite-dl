name: Create Reusable Tag

on:
  workflow_call:
    inputs:
      release_type:
        description: "The type of release to create (release or prerelease)"
        required: true
        type: string
    outputs:
      new_tag:
        description: "The newly created SemVer tag"
        value: ${{ jobs.tag.outputs.new_tag }}

jobs:
  tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create SemVer Tag based on release type
        id: create_tag
        run: |
          #!/bin/bash
          # Exit immediately if a command exits with a non-zero status.
          set -e
          # Be verbose and print commands for better debugging.
          set -x

          # 1. Fetch all tags and get the latest one.
          git fetch --tags
          latest_tag=$(git tag --sort=-v:refname | head -n 1)

          # 2. Determine the base version and whether the latest tag is a prerelease.
          base_version=""
          is_prerelease=false
          has_v_prefix=false

          if [ -z "$latest_tag" ]; then
            echo "No existing tags found. Base version will be 0.0.0."
            base_version="0.0.0"
          else
            echo "Latest tag is $latest_tag"
            
            # Check for 'v' prefix
            if [[ "$latest_tag" =~ ^v ]]; then
              has_v_prefix=true
              clean_tag="${latest_tag#v}"
            else
              clean_tag="$latest_tag"
            fi

            if echo "$clean_tag" | grep -q -- "-rc\."; then
              is_prerelease=true
              # Get version from prerelease tag e.g. 1.2.3-rc.4 -> 1.2.3
              base_version=$(echo "$clean_tag" | sed -E 's/-rc\.[0-9]+$//')
            else
              # It's a stable tag
              base_version="$clean_tag"
            fi
          fi
          echo "Base version for calculation is $base_version. Latest tag was a prerelease: $is_prerelease. Has 'v' prefix: $has_v_prefix"

          # 3. Get all commits since the latest tag was created.
          commits=""
          if [ -z "$latest_tag" ]; then
            commits=$(git log --oneline)
          else
            commits=$(git log "${latest_tag}"..HEAD --oneline)
          fi

          # 4. Determine the type of version bump needed based on commit messages.
          bump_type="none"
          if echo "$commits" | grep -q -E "(BREAKING CHANGE)|(!:)"; then
            bump_type="major"
          elif echo "$commits" | grep -qE "[a-f0-9]+ feat(\(.*\))?:"; then
            bump_type="minor"
          elif echo "$commits" | grep -qE "[a-f0-9]+ (fix|build|chore|ci|docs|perf|refactor|revert|style|test)(\(.*\))?:"; then
            bump_type="patch"
          fi
          echo "Determined bump type from commits: $bump_type"

          # 5. Calculate the next version string based on the bump type.
          IFS='.' read -r major minor patch <<< "$base_version"

          if [ "$bump_type" == "major" ]; then
            major=$((major + 1)); minor=0; patch=0;
          elif [ "$bump_type" == "minor" ]; then
            minor=$((minor + 1)); patch=0;
          elif [ "$bump_type" == "patch" ]; then
            # Special case: If we are on an RC and have a patch bump,
            # next_version should be the base_version itself (to promote to stable)
            # UNLESS it's already a stable tag.
            if [ "$is_prerelease" = false ]; then
              patch=$((patch + 1))
            fi
          fi
          next_version="${major}.${minor}.${patch}"
          echo "Next calculated version is $next_version"

          # 6. Determine the final tag based on the user's requested release type.
          RELEASE_TYPE="${RELEASE_TYPE:-release}"
          new_tag=""
          if [ "$RELEASE_TYPE" == "release" ]; then
            # --- User wants a STABLE release ---
            echo "ACTION: Selecting a stable release tag."
            if $is_prerelease && [ "$bump_type" == "none" ]; then
              # Rule 3: Promote a prerelease to stable if no new changes
              new_tag=$base_version
            else
              # Rule 4: Bump to the next calculated version
              new_tag=$next_version
            fi
          else
            # --- User wants a PRERELEASE ---
            echo "ACTION: Selecting a pre-release tag."
            if $is_prerelease && [ "$bump_type" == "none" ]; then
              # Rule 1: No new bumping commits, so just increment rc
              rc_number=$(echo "$latest_tag" | sed -E 's/.*-rc\.//')
              new_rc_number=$((rc_number + 1))
              new_tag="${base_version}-rc.${new_rc_number}"
            else
              # Rule 2: A version bump occurred, so start a new prerelease series.
              new_tag="${next_version}-rc.0"
            fi
          fi

          # Final check for the very first tag where logic might result in 0.0.0
          if [ "$new_tag" == "0.0.0" ] || [ "$new_tag" == "0.0.0-rc.0" ]; then
              if [ "$RELEASE_TYPE" == "release" ]; then
                  new_tag="0.1.0"
              else
                  new_tag="0.1.0-rc.0"
              fi
          fi

          # Re-add 'v' prefix if it was originally present
          if [ "$has_v_prefix" = true ]; then
            new_tag="v$new_tag"
          fi

          echo "Final selected tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Push new tag to repository
        if: steps.create_tag.outputs.new_tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag ${{ steps.create_tag.outputs.new_tag }}
          git push origin ${{ steps.create_tag.outputs.new_tag }}