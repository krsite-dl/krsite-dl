name: Create Reusable Tag

on:
  workflow_call:
    inputs:
      release_type:
        description: "The type of release to create (release or prerelease)"
        required: true
        type: string
    outputs:
      new_tag:
        description: "The newly created SemVer tag"
        value: ${{ jobs.tag.outputs.new_tag }}

jobs:
  tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create SemVer Tag based on release type
        id: create_tag
        run: |
          #!/bin/bash
          # Exit immediately if a command exits with a non-zero status.
          set -e
          # Be verbose and print commands for better debugging.
          set -x

          # 1. Fetch all tags and get the latest one.
          git fetch --tags
          latest_tag=$(git tag --sort=-v:refname | head -n 1)

          # 2. Determine the base version and whether the latest tag is a prerelease.
          base_version=""
          is_prerelease=false
          if [ -z "$latest_tag" ]; then
            echo "No existing tags found. Base version will be 0.0.0."
            base_version="0.0.0"
          else
            echo "Latest tag is $latest_tag"
            if echo "$latest_tag" | grep -q -- "-rc\."; then
              is_prerelease=true
              # Get version from prerelease tag e.g. 1.2.3-rc.4 -> 1.2.3
              base_version=$(echo "$latest_tag" | sed -E 's/-rc\.[0-9]+$//')
            else
              # It's a stable tag
              base_version="$latest_tag"
            fi
          fi
          echo "Base version for calculation is $base_version. Latest tag was a prerelease: $is_prerelease"

          # 3. Get all commits since the latest tag was created.
          commits=""
          if [ -z "$latest_tag" ]; then
            commits=$(git log --oneline)
          else
            commits=$(git log "${latest_tag}"..HEAD --oneline)
          fi

          # 4. Determine the type of version bump needed based on commit messages.
          bump_type="none"
          if echo "$commits" | grep -q -E "(BREAKING CHANGE)|(!)"; then
            bump_type="major"
          elif echo "$commits" | grep -q "feat"; then
            bump_type="minor"
          # Rule 6 & 7: 'fix' and other conventional commits trigger a patch.
          elif echo "$commits" | grep -q -E "^(fix|build|chore|ci|docs|perf|refactor|revert|style|test)(\(.*\))?:"; then
            bump_type="patch"
          fi
          echo "Determined bump type from commits: $bump_type"

          # 5. Calculate the next version string based on the bump type.
          major=$(echo $base_version | cut -d. -f1)
          minor=$(echo $base_version | cut -d. -f2)
          patch=$(echo $base_version | cut -d. -f3)

          if [ "$bump_type" == "major" ]; then
            major=$((major + 1)); minor=0; patch=0;
          elif [ "$bump_type" == "minor" ]; then
            minor=$((minor + 1)); patch=0;
          elif [ "$bump_type" == "patch" ]; then
            patch=$((patch + 1));
          fi
          next_version="${major}.${minor}.${patch}"
          echo "Next calculated version is $next_version"

          # 6. Determine the final tag based on the user's requested release type.
          new_tag=""
          if [ "${{ inputs.release_type }}" == "release" ]; then
            # --- User wants a STABLE release ---
            echo "ACTION: Selecting a stable release tag."
            if $is_prerelease; then
              # Rule 3: Promote a prerelease, e.g., 1.0.1-rc.5 -> 1.0.1
              new_tag=$base_version
            else
              # Rule 4: Bump a stable release, e.g., 1.0.1 -> 1.0.2
              new_tag=$next_version
            fi
          else
            # --- User wants a PRERELEASE ---
            echo "ACTION: Selecting a pre-release tag."
            if $is_prerelease && [ "$bump_type" == "none" ]; then
              # Rule 1: No new bumping commits, so just increment rc, e.g., 1.0.1-rc.0 -> 1.0.1-rc.1
              rc_number=$(echo "$latest_tag" | sed -E 's/.*-rc\.//')
              new_rc_number=$((rc_number + 1))
              new_tag="${base_version}-rc.${new_rc_number}"
            else
              # Rule 2 & others: A version bump occurred, so start a new prerelease series.
              # e.g., 1.0.1 -> 1.0.2-rc.0 OR 1.0.1-rc.5 + feat -> 1.1.0-rc.0
              new_tag="${next_version}-rc.0"
            fi
          fi

          # Final check for the very first tag where logic might result in 0.0.0
          if [ "$new_tag" == "0.0.0" ] || [ "$new_tag" == "0.0.0-rc.0" ]; then
              if [ "${{ inputs.release_type }}" == "release" ]; then
                  new_tag="0.1.0"
              else
                  new_tag="0.1.0-rc.0"
              fi
          fi

          echo "Final selected tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Push new tag to repository
        if: steps.create_tag.outputs.new_tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag ${{ steps.create_tag.outputs.new_tag }}
          git push origin ${{ steps.create_tag.outputs.new_tag }}